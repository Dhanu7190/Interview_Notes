What are the main features of Java?

Main Features of Java:

Object-Oriented ‚Äì Everything in Java is based on objects (encapsulation, inheritance, polymorphism).

Platform Independent ‚Äì "Write once, run anywhere" using JVM.

Simple & Secure ‚Äì No pointers, automatic memory management, strong type checking.

Robust ‚Äì Exception handling and garbage collection prevent crashes.

Multithreaded ‚Äì Supports concurrent execution of multiple threads.

High Performance ‚Äì Uses JIT (Just-In-Time) compiler for faster execution.

Distributed ‚Äì Supports RMI and networking for distributed applications.

Portable ‚Äì Code runs the same across all platforms.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is the difference between JDK, JRE, and JVM?

Difference between JDK, JRE, and JVM:

Component		Full Form							Purpose									Contains

JDK				Java Development Kit			Used to develop Java applications			JRE + Development tools (compiler javac, debugger, etc.)

JRE				Java Runtime Environment		Used to run Java applications				JVM + core libraries

JVM				Java Virtual Machine			Executes Java bytecode						Part of JRE; platform-dependent


When you compile and run a program:

JDK (javac) ‚Üí compiles code ‚Üí bytecode  

JVM (via JRE) ‚Üí executes bytecode  

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is bytecode in Java?

Bytecode in Java:

It‚Äôs the intermediate code generated by the Java compiler (.class file).

It‚Äôs platform-independent, meaning it can run on any system with a JVM.

JVM interprets or compiles bytecode into machine code at runtime (via JIT).

Example : 

javac Hello.java   # Produces Hello.class (bytecode)

java Hello         # JVM executes the bytecode

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Why is Java platform-independent?

Java is platform-independent because:

Java programs are compiled into bytecode (not machine-specific code).

The JVM (Java Virtual Machine) interprets or compiles this bytecode into machine code for the host OS.

So, the same .class file runs on any system that has a compatible JVM.

		Source Code (.java) ‚Üí Bytecode (.class) ‚Üí JVM (on any OS) ‚Üí Machine Code

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is the difference between == and .equals()

Operator			Used For					Compares											Example

==					Reference comparison		Checks if two references point to the same object	str1 == str2

.equals()			Content comparison			Checks if two objects have the same value			str1.equals(str2)

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is the difference between final, finally, and finalize()?

Difference between final, finally, and finalize():

Keyword / Method	Type			Purpose																										Example / Note

final				Keyword			Used to restrict ‚Äì variable (constant), method (cannot override), class (cannot inherit)					final int x = 10;

finally				Block			Used in exception handling; executes always, whether exception occurs or not								Used with try-catch-finally

finalize()			Method			Called by Garbage Collector before an object is destroyed (deprecated in Java 9+)							protected void finalize() { }

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are wrapper classes in Java?

Wrapper Classes in Java:

Wrapper classes convert primitive data types into objects.

They are found in java.lang package.

Useful for collections, autoboxing/unboxing, and object manipulation.

Primitive		Wrapper Class

int				Integer

char			Character

boolean			Boolean

double			Double

float			Float

long			Long

byte			Byte

short			Short

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is autoboxing and unboxing?

Autoboxing and Unboxing in Java:

Autoboxing ‚Üí Automatic conversion of primitive type to its wrapper object.

Unboxing ‚Üí Automatic conversion of wrapper object back to primitive type.

These features were introduced in Java 5 to make code cleaner and reduce manual conversions.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are access modifiers in Java?

Access Modifiers in Java:

They define visibility (scope) of classes, methods, and variables.

Modifier				Scope / Access												Used In

public					Accessible from anywhere									Classes, methods, variables

protected				Accessible within same package and by subclasses			Methods, variables

default (no modifier)	Accessible within same package only							Classes, methods, variables

private					Accessible within same class only							Methods, variables

_______________________________________________________________________________________________________________________________________________________________________________________________________________

What is the difference between static and non-static methods?

Difference between static and non-static methods:

Type					Belongs To			Accessed By					Can Access														Memory

Static Method			Class				ClassName.methodName()		Only static variables/methods directly							Loaded once in memory

Non-Static Method		Object				object.methodName()			Both static and non-static members								Each object has its own copy

_______________________________________________________________________________________________________________________________________________________________________________________________________________

What are the four main principles of OOPs?

Encapsulation ‚Äì Wrapping data and methods into a single unit (class); restricts direct access using private variables and getters/setters.

Inheritance ‚Äì One class acquires properties and behavior of another using extends keyword.

Polymorphism ‚Äì Ability to perform a single action in different forms (method overloading & overriding).

Abstraction ‚Äì Hiding implementation details and showing only essential features (using abstract classes or interfaces).

_______________________________________________________________________________________________________________________________________________________________________________________________________________

What is encapsulation in Java?

Encapsulation in Java:

It is the process of binding data (variables) and methods that operate on that data into a single unit (class).

It helps in data hiding, ensuring controlled access through getters and setters.

_______________________________________________________________________________________________________________________________________________________________________________________________________________

What is inheritance in Java?

Inheritance in Java:

It is a mechanism where one class acquires the properties and behavior of another using the extends keyword.

Promotes code reusability and method overriding.

‚úÖ Types:

Single

Multilevel

Hierarchical

(Note: Multiple inheritance not supported with classes, but possible with interfaces.)

_______________________________________________________________________________________________________________________________________________________________________________________________________________

What is polymorphism?

Polymorphism in Java:

It means "many forms" ‚Äî the ability of a single function, method, or object to behave differently based on context.

Enables method overloading (compile-time) and method overriding (runtime).

‚úÖ Types:

Compile-time Polymorphism ‚Äì Achieved by method overloading.

Runtime Polymorphism ‚Äì Achieved by method overriding.

_______________________________________________________________________________________________________________________________________________________________________________________________________________

What is abstraction?

Abstraction in Java:

It is the process of hiding implementation details and showing only essential features to the user.

Achieved using abstract classes and interfaces.

Helps in reducing complexity and improving maintainability.

_______________________________________________________________________________________________________________________________________________________________________________________________________________

Interface vs Abstract Class in Java

Both interfaces and abstract classes are used to achieve abstraction ‚Äî but they work differently and serve different design purposes.

Concept						Description

Interface					A contract that defines what a class should do (but not how). It contains abstract methods (and from Java 8 onward, default & static methods).

Abstract Class				A class that can have abstract methods (without body) and non-abstract methods (with implementation). Used to share common code among subclasses.


Feature						Interface																																						Abstract Class

Purpose						Defines a contract (what to do)																																Defines a base class (how to do it partially)

Methods						Only abstract methods (until Java 7), default & static (Java 8+), private (Java 9+)																			Can have abstract and non-abstract methods

Variables					public static final (constants) only																														Can have instance & static variables

Constructors				‚ùå Not allowed																																				‚úÖ Can have constructors

Access Modifiers			All methods are implicitly public																															Can use any (public, protected, private)

Multiple Inheritance		‚úÖ A class can implement multiple interfaces																												‚ùå A class can extend only one abstract class

Implementation				Class must implement all abstract methods																													Subclass can choose to override some or all abstract methods

Default Behavior			Cannot provide behavior until Java 8																														Can provide default behavior via concrete methods

Extends/Implements			A class implements an interface																																A class extends an abstract class

State (Fields)				Cannot have state (only constants)																															Can maintain state (instance variables)

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is method overloading and method overriding?

Method Overloading and Method Overriding in Java:

Feature					Method Overloading														Method Overriding

Definition				Same method name, different parameters (within same class).				Same method name, same parameters (in parent‚Äìchild classes).

Type					Compile-time polymorphism												Runtime polymorphism

Inheritance Required	No																		Yes

Return Type				Can be different (if parameters differ)									Must be the same or covariant

Access Modifier			Any																		Cannot be more restrictive

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Can we override a static method in Java?

‚ùå No, we cannot override a static method in Java.

Reason:

Static methods belong to the class, not to an instance (object).

So they are hidden, not overridden ‚Äî this is called method hiding.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is the difference between super() and this()?

Difference between super() and this():

Keyword		Purpose											Used For														Must Be First Statement

super()		Calls the parent class constructor				Accessing parent class members									‚úÖ Yes

this()		Calls another constructor in the same class		Constructor chaining within same class							‚úÖ Yes

‚ö†Ô∏è Both cannot be used together in the same constructor call.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Can an interface have a constructor?

No, an interface cannot have a constructor in Java.

Reason:

Interfaces cannot be instantiated directly.

They are meant to define abstract behavior, not maintain state.

All fields in an interface are implicitly public static final, and all methods are public abstract (except default/static methods in Java 8+).

Only classes and abstract classes can have constructors.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is exception handling in Java?

Exception Handling in Java:

It is a mechanism to handle runtime errors so the program can continue running smoothly.

Uses try, catch, finally, throw, and throws keywords.

Prevents abnormal program termination and improves reliability.

Hierarchy:

Throwable ‚Üí Exception ‚Üí RuntimeException / Checked Exceptions

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is the difference between checked and unchecked exceptions?

Difference between Checked and Unchecked Exceptions:

Type						Inheritance												Checked at Compile Time?		Example											Handling Requirement

Checked Exceptions			Subclass of Exception (but not RuntimeException)		‚úÖ Yes							IOException, SQLException						Must be handled using try-catch or declared with throws

Unchecked Exceptions		Subclass of RuntimeException							‚ùå No							NullPointerException, ArithmeticException		Option

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is the base class for all exceptions?

The base class for all exceptions in Java is java.lang.Throwable.

java.lang.Object  
  
  ‚Ü≥ java.lang.Throwable  

        ‚Ü≥ java.lang.Exception        // for recoverable conditions  

        ‚Ü≥ java.lang.Error            // for serious system errors
		
Exception ‚Üí used for application-level issues (e.g., IOException, SQLException).

Error ‚Üí used for JVM-related issues (e.g., OutOfMemoryError).

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is the difference between throw and throws?

Difference between throw and throws:

Keyword		Used For										Position					Purpose												Example

throw		To explicitly throw an exception				Inside a method				Used to create and throw an exception object		throw new IOException("Error");

throws		To declare exceptions a method might throw		In method signature			Warns the caller to handle the exception			void read() throws IOException

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What happens if an exception is not caught?

If an exception is not caught in Java:

The JVM‚Äôs default exception handler handles it.

It prints the exception‚Äôs name, description, and stack trace (line number where it occurred).

Then the program terminates abruptly.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is a thread in Java?

Thread in Java:

A thread is the smallest unit of execution within a process.

It allows concurrent execution of two or more parts of a program.

Threads in Java are managed by the JVM.

‚úÖ Two ways to create a thread:

Extend Thread class

Implement Runnable interface

start() creates a new thread and calls run() internally.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are the two ways to create a thread?

Two ways to create a thread in Java:

By extending the Thread class

Override the run() method.

Call start() to begin execution.

By implementing the Runnable interface

Implement the run() method.

Pass the Runnable object to a Thread and call start().

Implementing Runnable is preferred ‚Äî it allows extending other classes.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is the difference between sleep() and wait()?

Difference between sleep() and wait() in Java:

Feature				sleep()											wait()

Belongs To			Thread class									Object class

Lock Release		‚ùå Does not release lock						‚úÖ Releases lock

Usage				Used to pause execution for a specific time		Used for thread communication (e.g., in synchronized blocks)

Call Requires		Can be called anywhere							Must be called inside a synchronized block/method

Throws				InterruptedException							InterruptedException

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is synchronization in Java?

Synchronization in Java:

It is a mechanism to control access to shared resources by multiple threads.

Ensures that only one thread executes a synchronized block or method at a time, preventing data inconsistency.

‚úÖ Types:

Synchronized method

Synchronized block

Used to achieve thread safety in multithreaded programs.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is a deadlock?

Deadlock in Java:

A deadlock occurs when two or more threads are waiting for each other‚Äôs locked resources, and none of them can proceed.

It results in threads being permanently blocked.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is the Collection Framework in Java?

Collection Framework in Java:

It is a set of classes and interfaces in java.util package used to store, manipulate, and retrieve groups of objects efficiently.

Provides data structures like List, Set, Queue, and Map.

Offers built-in methods for searching, sorting, insertion, deletion, and iteration.

Key Interfaces:

Collection (root interface)

List ‚Äì Ordered, allows duplicates (ArrayList, LinkedList)

Set ‚Äì Unordered, no duplicates (HashSet, TreeSet)

Queue ‚Äì FIFO structure (PriorityQueue, ArrayDeque)

Map ‚Äì Key‚Äìvalue pairs (HashMap, TreeMap)

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is the difference between List, Set, and Map?

Difference between List, Set, and Map in Java:

Feature			List									Set														Map

Implements		List interface							Set interface											Map interface

Stores			Ordered collection of elements			Unordered collection of unique elements					Collection of key‚Äìvalue pairs

Duplicates		‚úÖ Allowed								‚ùå Not allowed											‚ùå Keys not allowed, ‚úÖ Values can repeat

Order			Maintains insertion order				No guaranteed order (HashSet), sorted in TreeSet		No guaranteed order (HashMap), sorted in TreeMap

Access			By index								By iterator												By key

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Difference between ArrayList and LinkedList?

Feature						ArrayList								LinkedList

Underlying Structure		Dynamic array							Doubly linked list

Access Time					Fast ‚Äî O(1) (index-based)				Slow ‚Äî O(n) (sequential traversal)

Insertion / Deletion		Slow ‚Äî shifting required				Fast ‚Äî just node pointer changes

Memory Usage				Less (stores only data)					More (stores data + node links)

Best For					Frequent read/access operations			Frequent insert/delete operations

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Difference between HashSet and TreeSet?

Feature						HashSet									TreeSet

Ordering					No guaranteed order						Sorted in ascending (natural) order

Underlying Structure		Hash table								Red-Black tree (self-balancing BST)

Performance					Faster ‚Äî O(1) for add, remove, search	Slower ‚Äî O(log n) for operations

Null Elements				Allows one null element					‚ùå Does not allow null

Use Case					When order doesn‚Äôt matter				When sorted order is require

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Difference between HashMap and Hashtable?

Feature					HashMap												Hashtable

Synchronization			‚ùå Not synchronized (not thread-safe)				‚úÖ Synchronized (thread-safe)

Null Keys/Values		Allows one null key and multiple null values		‚ùå Does not allow null keys or values

Performance				Faster (no synchronization overhead)				Slower (due to synchronization)

Introduced In			Java 1.2 (part of Collections Framework)			Java 1.0 (legacy class)

Iteration				Uses Iterator (fail-fast)							Uses Enumerator (not fail-fast)

_________________________________________________________________________________________________________________________________________________________________________________________________________________

How does HashMap work internally?

Internal Working of HashMap in Java:

Data Structure:

Uses an array of buckets (each bucket is a linked list or tree in Java 8+).

Each entry is a Map.Entry(key, value, hash, next).

Insertion (put()):

Computes hash code of the key using hashCode() method.

Determines bucket index = hash % capacity.

If no entry exists ‚Üí adds new node.

If key already exists ‚Üí updates value.

If collision occurs ‚Üí stores entry in the same bucket (linked list or tree).

If a bucket‚Äôs linked list size > 8 ‚Üí converted to a Red-Black Tree (Java 8+).

Retrieval (get()):

Calculates hash and finds bucket.

Compares keys using equals() to return the correct value.

Rehashing:

When load factor (default 0.75) is exceeded, capacity is doubled, and entries are rehashed.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is the difference between Comparable and Comparator?

Feature							Comparable										Comparator

Package							java.lang										java.util

Purpose							Defines natural ordering of objects				Defines custom ordering

Method							compareTo(Object o)								compare(Object o1, Object o2)

Affects Original Class?			‚úÖ Yes (class must implement it)				‚ùå No (defined externally)

Used When						Default sorting is enough						Multiple or complex sort criteria needed

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is the difference between fail-fast and fail-safe iterators?

Feature							Fail-Fast Iterator																	Fail-Safe Iterator

Behavior on Modification		Throws ConcurrentModificationException if collection is modified during iteration	Doesn‚Äôt throw exception; works on a copy of the collection

Underlying Collection			Directly iterates on the original collection										Iterates on a cloned copy

Examples						ArrayList, HashMap, HashSet															ConcurrentHashMap, CopyOnWriteArrayList

Performance						Faster																				Slower (due to copying)

Use Case						Non-concurrent applications															Concurrent (multi-threaded) applications

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is the difference between HashMap and ConcurrentHashMap?

Feature				HashMap															ConcurrentHashMap

Thread-Safety		‚ùå Not thread-safe												‚úÖ Thread-safe

Synchronization		None															Uses internal locking (segment-based / bucket-level)

Null Keys/Values	Allows one null key and multiple null values					‚ùå Does not allow null keys or values

Performance			Faster in single-threaded apps									Optimized for multi-threaded access

Fail Behavior		Fail-fast iterator (throws ConcurrentModificationException)		Fail-safe iterator (no exception)

Use Case			Single-threaded environment										Concurrent/multi-threaded applications

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are generics in Java?

Generics in Java:

Generics enable type safety by allowing classes, interfaces, and methods to operate on specific data types without casting.

Introduced in Java 5 to detect type errors at compile time.

‚úÖ Benefits:

Type safety (no ClassCastException)

Code reusability

Compile-time checking

Without generics, you‚Äôd use raw types, which are error-prone and unsafe.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are the main features introduced in Java 8?

Lambda Expressions ‚Äì Enables writing functional-style code.

Functional Interfaces ‚Äì Interfaces with only one abstract method, e.g. Runnable, Comparator.

Stream API ‚Äì For filtering, mapping, and processing collections efficiently.

Default & Static Methods in Interfaces ‚Äì Allows adding new methods without breaking existing code.

Optional Class ‚Äì To handle null values safely.

Date and Time API (java.time) ‚Äì Modern, immutable time classes (LocalDate, LocalTime, LocalDateTime).

Nashorn JavaScript Engine ‚Äì To execute JavaScript code on the JVM.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are functional interfaces in Java?

A functional interface is an interface that contains exactly one abstract method.

It can, however, include default methods, static methods, and methods from Object (like toString() or equals()).

@FunctionalInterface

interface Greeting {

    void sayHello(String name);
}

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is a lambda expression?

Lambda Expression in Java:

A lambda expression is a short way to write anonymous functions (without a name).

Introduced in Java 8, it enables functional programming and cleaner code, especially with collections and streams.

Benefits:

Reduces boilerplate code

Improves readability

Works well with Stream API and functional interfaces
_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are streams in Java?

Streams in Java (Java 8):

A Stream is a sequence of elements supporting functional-style operations like filtering, mapping, and reducing.

It helps process collections of data efficiently and declaratively (without loops).

Found in java.util.stream package.

‚úÖ Key Features:

Does not store data (operates on collection data).

Lazy evaluation (operations run only when needed).

Supports parallel processing (parallelStream()).

Common Stream Operations:

Intermediate: filter(), map(), sorted()

Terminal: forEach(), collect(), count(), reduce()

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is the difference between map() and flatMap()?

Difference between map() and flatMap() in Java Streams:

Feature				map()														flatMap()

Purpose				Transforms each element into one new value					Transforms each element into a stream and then flattens all streams into one

Return Type			Stream<T> ‚Üí Stream<R>										Stream<T> ‚Üí Stream<R> (after flattening nested streams)

Used When			Each input maps to a single output							Each input maps to multiple outputs (nested collections)

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is Optional in Java 8?

Optional in Java 8:

Optional<T> is a container object that may or may not hold a non-null value.

It helps avoid NullPointerException by forcing you to explicitly handle the possibility of null.

Defined in java.util package.

‚úÖ Common Methods:

of(value) ‚Äì creates Optional with a non-null value

ofNullable(value) ‚Äì allows null

empty() ‚Äì creates an empty Optional

isPresent() / isEmpty() ‚Äì checks value presence

orElse(defaultValue) ‚Äì provides fallback

ifPresent(consumer) ‚Äì executes if value exists

Purpose:

Makes code more readable, null-safe, and functional by replacing explicit null checks.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is a Default Method?

A default method in an interface is a method that has a body (implementation).

It uses the keyword default.

Why Were Default Methods Introduced in Java 8?

Before Java 8:

Interfaces could only have abstract methods (no implementation).

If you added a new method to an interface, all existing classes that implemented it would break (because they‚Äôd be forced to implement the new method).

This caused backward compatibility problems when evolving APIs.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are method references?

Method References in Java (Java 8):

A method reference is a shorthand for calling a method using a lambda expression.

It allows referencing an existing method by name, improving code readability.

Used with functional interfaces (like Runnable, Consumer, etc.).

Purpose: Cleaner, more readable alternative to simple lambdas.
_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is garbage collection in Java?

Garbage Collection (GC) in Java:

It is the automatic process by which the JVM frees memory by removing objects no longer referenced by any part of the program.

Eliminates the need for manual memory management (like in C/C++).

‚úÖ Key Points:

Managed by the JVM.

Runs in the background.

Uses algorithms like Mark and Sweep, Generational GC, and G1 GC.

Objects on the heap are eligible for GC when they have no live references.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Why is String immutable in Java?

String is immutable in Java because:

Security:

Strings are often used in sensitive operations (e.g., file paths, URLs, database credentials).

If mutable, malicious code could alter their values after creation.

Caching (String Pool):

Java uses a String pool to store unique string literals.

Immutability allows strings to be reused safely, improving performance and memory usage.

Thread-Safety:

Immutable objects are inherently thread-safe, as their value cannot change after creation.

HashCode Consistency:

Since value never changes, the hashCode remains constant, making Strings reliable for use in HashMap, HashSet, etc.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is a HashMap?

A HashMap stores data as key‚Äìvalue pairs and allows fast lookup using the key.

Internal structure

Internally, it uses an array of buckets.

Each bucket stores a linked list (or tree) of entries (key, value pairs).

_________________________________________________________________________________________________________________________________________________________________________________________________________________

No, we cannot override static methods in Java.

üîπ Why?

Because static methods belong to the class, not to an instance (object).

Overriding is based on runtime polymorphism (deciding which method to call at runtime based on the actual object type).

But static methods are resolved at compile time ‚Äî so they cannot be overridden.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Before Java 8, interfaces could only have abstract methods ‚Äî meaning:

You had to implement every method in the class that implemented the interface.

If you added a new method to an interface, all existing implementing classes broke üò¨.

So Java 8 introduced:

Default methods ‚Üí for adding new methods without breaking existing code.

Static methods ‚Üí for adding utility/helper methods specific to the interface.

Feature								Default Method									Static Method

Introduced in						Java 8												Java 8

Has body (implementation)?			‚úÖ Yes												‚úÖ Yes

Belongs to							Instance (object)								Interface (class-level)

Can be overridden?					‚úÖ Yes												‚ùå No

Accessed by							Object											Interface name

Use case							Backward compatibility / reusable logic  		Utility or helper logic

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Should we give @functionalInterface on the top of a functionalinterface

No ‚Äî you don‚Äôt have to use @FunctionalInterface, but you should ‚Äî it‚Äôs a good practice.

A Functional Interface is an interface that has exactly one abstract method.

_________________________________________________________________________________________________________________________________________________________________________________________________________________


What is Java Memory Management?

Java manages memory automatically using the JVM (Java Virtual Machine) ‚Äî it allocates, uses, and cleans up memory for you.

This is done through:

Automatic memory allocation

Garbage collection (to remove unused objects)

Area					Stores											Managed by

Heap					Objects and instance variables					Garbage Collector

Stack					Local variables and method calls				Each thread

Metaspace				Class metadata and static info					JVM (native memory)

PC Register				Current instruction of thread					JVM

Native Method Stack		Native (C/C++) code calls						JVM

_________________________________________________________________________________________________________________________________________________________________________________________________________________

.java file
   ‚Üì
javac (Compiler)
   ‚Üì
.class (Bytecode)
   ‚Üì
Class Loader
   ‚Üì
Bytecode Verifier
   ‚Üì
JVM Memory Allocation
   ‚Üì
Execution Engine (Interpreter + JIT)
   ‚Üì
main() Execution
   ‚Üì
Garbage Collection
   ‚Üì
Program Ends
