What is Angular and how is it different from AngularJS?

Angular is a TypeScript-based front-end framework developed by Google for building dynamic single-page applications (SPAs). It follows a component-based architecture, making applications more modular, testable, and scalable.

AngularJS, on the other hand, was the first version of the framework built using JavaScript and based on the MVC (Model-View-Controller) pattern.

Performance: Angular is faster because of Ahead-of-Time (AOT) compilation and efficient change detection.

Mobile Support: Angular is built with mobile support in mind, unlike AngularJS.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is a Component?

A Component in Angular is the building block of the user interface (UI).

It controls a specific portion of the screen ‚Äî known as a view ‚Äî and contains both the logic and the template (HTML) for that section.

Each component in Angular is a TypeScript class that interacts with the HTML template to define how data is displayed and how the app responds to user actions.

Components help make the application modular, maintainable, and reusable.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are Templates in Angular?

A template in Angular is the HTML view of a component.

It defines how the UI looks and what should be displayed to the user.

Templates also allow Angular-specific features like:

Data binding

Interpolation

Directives (*ngIf, *ngFor)

Event binding

Pipes

Basically, template = HTML + Angular features.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is Metadata in Angular?

Metadata is the information (configuration) that we pass inside decorators

so Angular knows how to use that class.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are Decorators in Angular?

A decorator is a special TypeScript feature (a function) that adds extra behavior or metadata to a class, method, property, or parameter.

Angular uses decorators to understand:

What is a component?

What is a service?

What is a module?

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is a Module in Angular?

A Module in Angular is a container that groups together related components, directives, pipes, and services into a cohesive block of functionality.

It helps organize the application into logical sections, making the app more scalable, maintainable, and modular.

Every Angular application must have at least one module, known as the root module.

Each module is defined using the @NgModule decorator, which provides metadata about the module such as what it declares, imports, and exports.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Difference Between Template-Driven and Reactive Forms in Angular

In Angular, forms are used to handle user input, validation, and data binding.

There are two main approaches ‚Äî Template-driven forms and Reactive forms ‚Äî both achieving the same goal but with different implementation styles.

1. Template-Driven Forms

Definition:

Template-driven forms are driven by the template (HTML). Most of the form logic is defined using Angular directives in the HTML.

Characteristics:

Simpler and easier to use for small forms.

Uses two-way data binding with [(ngModel)].

Angular automatically creates the FormControl instances.

Suitable for simple scenarios like contact or login forms.

2. Reactive Forms

Definition:

Reactive forms are driven by the component (TypeScript). The form model and validation logic are defined programmatically in the component class.

Characteristics:

More scalable, predictable, and testable.

Uses explicit data flow with reactive programming principles.

Form controls are created using FormGroup and FormControl.

Ideal for complex forms with dynamic validation or conditional logic.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Data Binding in Angular

Data binding in Angular is the process that connects the component‚Äôs data (TypeScript class) with the template (HTML view).

It allows communication between the component (logic) and the DOM (UI) ‚Äî either from component to view, from view to component, or both ways.

Angular provides four main types of data binding:

1. Interpolation ({{ }})

Direction: Component ‚Üí View

Purpose: To display dynamic data from the component in the HTML template.

2. Property Binding ([ ])

Direction: Component ‚Üí View

Purpose: To bind HTML element or directive properties to component variables.

3. Event Binding (( ))

Direction: View ‚Üí Component

Purpose: To handle user actions (like clicks, input, or key presses) and call component methods.

4. Two-Way Binding ([( )])

Direction: Component ‚Üî View and View ‚Üî Component

Purpose: To keep data in sync between the component and the view ‚Äî when one changes, the other updates automatically.

Uses ngModel from FormsModule.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is Dependency Injection (DI) in Angular?

Dependency Injection (DI) is a design pattern used in Angular to create and manage dependencies (like services or classes) efficiently.

In simple terms ‚Äî instead of a component creating its own dependencies, Angular injects them automatically, which makes the code more modular, reusable, and testable.

Angular has a built-in DI framework, meaning you can easily define how dependencies are provided and shared across the app.

Why is Dependency Injection Useful?

Improves Reusability

The same service can be injected into multiple components without recreating it.

Enhances Testability

Dependencies can be easily mocked or replaced during unit testing.

Better Maintainability

Components don‚Äôt depend on concrete classes; they depend on abstractions, making the system more flexible.

Singleton Behavior

Angular ensures one instance of the dependency (if provided in root) is shared across the app, optimizing memory usage.

Loose Coupling

Components and services remain independent, reducing interdependency and making the code cleaner.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Difference Between constructor() and ngOnInit() in Angular

Both constructor and ngOnInit() are part of a component‚Äôs lifecycle, but they serve different purposes and are executed at different stages of component creation.

1. constructor()

Definition:

constructor is a TypeScript feature ‚Äî not specific to Angular.

It is called when the component class is instantiated (i.e., when Angular creates the component object).

Purpose:

Used for dependency injection (to receive injected services).

Used for basic initialization that doesn‚Äôt depend on bindings or DOM elements.

2. ngOnInit()

Definition:

ngOnInit() is an Angular lifecycle hook that belongs to the OnInit interface.

It runs after the component is initialized and after Angular has set all input properties.

Purpose:

Ideal for initializing component data.

Commonly used to fetch data from APIs or services.

Ensures that inputs are available and ready to use.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Lifecycle Hooks in Angular

In Angular, every component has a lifecycle ‚Äî from creation to destruction.

Lifecycle hooks are special methods that allow developers to tap into key moments of this process, such as initialization, change detection, and cleanup.

These hooks help manage component behavior, data flow, and resource cleanup efficiently.

List of Major Lifecycle Hooks (in order of execution)

Hook													Purpose

ngOnChanges()				Called before ngOnInit() and whenever an input property changes. Used to respond to changes in @Input() values.

ngOnInit()					Called once after the first ngOnChanges(). Ideal for initialization logic like fetching data from APIs.

ngDoCheck()					Called during every change detection cycle. Used to detect and act upon changes that Angular doesn‚Äôt catch automatically.

ngAfterContentInit()		Called once after content projection (<ng-content>) has been initialized.

ngAfterContentChecked()		Called after Angular checks the projected content. Runs after every change detection cycle.

ngAfterViewInit()			Called once after the component‚Äôs view (and child views) are initialized. Commonly used with @ViewChild.

ngAfterViewChecked()		Called after Angular checks the component‚Äôs views and child views.

ngOnDestroy()				Called just before the component is destroyed. Used for cleanup (like unsubscribing from Observables, removing event listeners).

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are Directives in Angular?

Directives in Angular are special instructions in the DOM that change the appearance or behavior of elements, components, or other directives.

In simpler terms, directives help Angular manipulate the DOM ‚Äî by adding, removing, or modifying elements dynamically based on logic.

Every Angular application uses directives extensively (for example, *ngIf, *ngFor, [(ngModel)], etc.).

1. Structural Directives

Purpose:

Structural directives change the DOM structure by adding or removing elements.

Syntax:

Always prefixed with an asterisk (*) because they modify the HTML structure.

2. Attribute Directives

Purpose:

Attribute directives change the appearance or behavior of an existing DOM element, component, or directive ‚Äî without adding or removing elements.

Syntax:

Used like regular HTML attributes, usually enclosed in square brackets [ ].

3. Component Directives

Definition:

Technically, every Angular component is also a directive with a template.

It‚Äôs a special type of directive that controls a view.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are Pipes in Angular?

Pipes in Angular are used to transform data before displaying it in the view (HTML).

They take in a value, process it, and return a formatted output ‚Äî without changing the actual data in the component.

Pipes are especially useful for tasks like formatting dates, numbers, strings, and more ‚Äî directly in the template.

You apply a pipe using the pipe symbol (|) in your HTML.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Difference between pure and impure pipes?

In Angular, pipes are used to transform data in templates.

They can be classified into pure and impure based on how frequently they execute and when they detect changes in data.

1. Pure Pipes

Definition:

A pure pipe is executed only when the input value changes (by reference).

It does not re-run if the input data changes internally (e.g., an array element changes but the reference remains the same).

Default behavior:

All Angular pipes are pure by default.

Performance:

Very efficient, as Angular calls them only when necessary (during change detection).

Use case:

Best for stateless transformations ‚Äî e.g., formatting text, numbers, or dates.

2. Impure Pipes

Definition:

An impure pipe runs on every change detection cycle, regardless of whether the input value changes or not.

This means it can detect changes within arrays, objects, or collections.

Performance:

Less efficient because it executes frequently, even for minor changes.

Use case:

Useful for dynamic or mutable data, like arrays that frequently update or filter results.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are Built-in Pipes in Angular?

Built-in pipes are the pipes that Angular provides out-of-the-box to transform data directly in templates.

Pipes help you format data like:

Dates

Numbers

Currency

Percent

Text case

JSON

You use them with the | pipe operator.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is Angular Router?

The Angular Router is a built-in module that enables navigation between different views or components within a Single Page Application (SPA) ‚Äî without reloading the entire page.

It allows developers to define routes (URLs) that map to specific components, making the application behave like a multi-page app while still running on a single HTML page.

Why Do We Need Angular Router?

In a traditional web application, navigating to a new page causes the browser to reload and fetch a new HTML document.

But in Angular (SPA), we need navigation without full page reloads ‚Äî and that‚Äôs where the Angular Router comes in.

It provides:

Seamless navigation between components.

Dynamic URL handling.

Better user experience through faster transitions.

Support for parameters, guards, lazy loading, and nested routes.

How It Works

Routes are defined as path-component mappings in a routing module (usually app-routing.module.ts).

The router listens to URL changes and renders the corresponding component dynamically in the <router-outlet>.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is Lazy Loading in Angular?

Lazy Loading in Angular is a technique used to load feature modules only when they are needed, rather than loading everything at application startup.

It helps improve application performance by reducing the initial bundle size ‚Äî the browser downloads only the essential code at first, and loads other parts on demand (when the user navigates to them).

In contrast, Eager Loading loads all modules upfront, which can slow down the initial page load, especially in large applications.

Why Use Lazy Loading?

Faster Initial Load Time ‚Äì

Only necessary modules are loaded initially, making the app start faster.

Optimized Performance ‚Äì

Reduces memory usage and bandwidth consumption by loading modules as needed.

Better User Experience ‚Äì

Users don‚Äôt have to wait for all features to download before interacting with the app.

Efficient Code Splitting ‚Äì

Angular‚Äôs router automatically splits the app into smaller chunks.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are Route Guards in Angular?

Route Guards in Angular are interfaces that control navigation ‚Äî they decide whether a user can access or leave a specific route.

They act as gatekeepers for your routes, helping implement features like authentication, authorization, unsaved changes warnings, and pre-loading data before navigation.

Route Guards return a boolean (true / false) or an Observable/Promise resolving to a boolean, which determines whether the navigation is allowed or not.

Guard			Purpose

CanActivate		Checks if a route can be activated (access control).

CanDeactivate	Checks if a route can be left (unsaved changes warning).

Resolve			Pre-fetches data before activating a route.

CanLoad			Prevents lazy-loaded modules from loading until conditions are met.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Difference Between routerLink and navigate() in Angular

In Angular, both routerLink and navigate() are used for routing and navigation,

but they are used in different contexts ‚Äî one in templates (HTML) and the other in TypeScript (component logic).

1. routerLink

Type: Template directive (used in HTML).

Purpose: Used for declarative navigation ‚Äî when you want to create clickable links in the template.

Usage: Commonly used inside anchor (<a>) or button elements.

2. navigate()

Type: Method (used in TypeScript).

Purpose: Used for programmatic navigation ‚Äî when you want to navigate based on logic or user actions (like button clicks or conditions).

Usage: Invoked using Angular‚Äôs Router service.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is a Service in Angular?

A Service in Angular is a reusable class that contains business logic, data, or functionality that can be shared across multiple components.

Services help keep components clean and focused on the UI, while the logic (like API calls, data processing, or utility functions) is handled separately.

They promote code reusability, separation of concerns, and maintainability.

ng generate service user   or   	ng g s user


user.service.ts

user.service.spec.ts

_________________________________________________________________________________________________________________________________________________________________________________________________________________


Difference Between navigate() and navigateByUrl()

Both methods belong to the Angular Router and are used for programmatic navigation, but they differ slightly in how they handle URLs.

Aspect	               				navigate()	 																			navigateByUrl()

Definition					Used for navigation by building the URL from an array of route segments.		Used for navigation by passing the full URL as a string.

Parameters					Accepts an array of path segments and optional navigation extras.				Accepts a single string representing the complete URL.

When to Use					When you need relative navigation or parameters.								When you already know the absolute path or a full URL.

Example Usage				this.router.navigate(['user', id]);												this.router.navigateByUrl('/user/5');

Supports Route Parameters	‚úÖ Yes																			‚úÖ Yes, but must be included manually in the URL

Supports Relative Paths		‚úÖ Yes ({ relativeTo: this.route })												‚ùå No (always absolute)

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Providing a Service in Angular ‚Äî providedIn vs providers Array

Services in Angular can be provided in different ways, which determines their scope and lifetime.

1. Using providedIn (Recommended)

Defined inside the @Injectable() decorator.

Automatically registers the service with the root injector (singleton across the app).

Angular‚Äôs tree-shaking removes it from the final bundle if unused.

2. Using providers Array

You can also provide a service:

In a module ‚Üí Service is available to all components in that module.

In a component ‚Üí Service instance is unique to that component and its children.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

How Does HttpClient Work in Angular?

The HttpClient in Angular is a built-in service (from the @angular/common/http package) used to make HTTP requests to RESTful APIs.

It allows your Angular application to communicate with backend servers ‚Äî to send or receive data ‚Äî using HTTP methods like GET, POST, PUT, DELETE, etc.

It‚Äôs based on Observables, provided by RxJS, which makes it powerful for handling asynchronous operations, like fetching or updating data from an API.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What Are HTTP Interceptors in Angular?

HTTP Interceptors in Angular are special classes that can inspect, modify, or handle HTTP requests and responses before they reach the server or application.

They are part of Angular‚Äôs HttpClient module and are used for cross-cutting concerns like:

Attaching authentication tokens,

Logging network requests,

Handling global errors,

Modifying response data.

They work like a middleware that sits between the application and the server.

Difference Between Request and Response Interceptors

Aspect							Request 																	Interceptor	Response Interceptor

Purpose					Modifies or handles outgoing requests before they are sent to the server.			Modifies or handles incoming responses before they reach the application

						Add authentication tokens (JWT) to headers.											Handle global HTTP errors.

Typical Use Cases		Add custom headers (e.g., Content-Type, Accept).									Transform or format response data.
						
 						Log outgoing requests.																Log responses or retry failed requests.					
 																											
When It Executes		Before the request leaves the client.												After the server sends back a response.

Return Type				HttpRequest (modified or cloned)													HttpResponse (modified, handled, or passed through)

_________________________________________________________________________________________________________________________________________________________________________________________________________________

How Do You Handle Errors in HttpClient (Using RxJS catchError)?

In Angular, when you make HTTP requests using HttpClient, errors can occur due to:

Network issues

Server failures (like 500 Internal Server Error)

Invalid URLs

Unauthorized access (401/403 errors), etc.

To handle these errors gracefully, Angular provides the catchError operator from RxJS, which allows you to catch and handle errors in an observable stream.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are Angular Interceptors?

An HTTP Interceptor in Angular is a special service that can intercept and modify HTTP requests and responses made using the HttpClient module.

Think of it like a middleware that sits between your Angular app and the server ‚Äî it can log requests, attach authentication tokens, handle global errors, or modify response data before it reaches your components.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is an Observable in Angular?

An Observable is a core concept from RxJS (Reactive Extensions for JavaScript) that represents a stream of asynchronous data that can be observed over time.

It allows you to subscribe to data changes, react to new values, handle errors, and even cancel ongoing operations.

Observables are heavily used in Angular ‚Äî especially in HttpClient, Forms, and Event handling ‚Äî because they make it easier to manage asynchronous and reactive programming.

Key Concepts:

An Observable can emit multiple values over time (unlike a Promise, which resolves once).

You can subscribe to start listening and unsubscribe to stop listening (important to prevent memory leaks).

Observables can be combined, filtered, or transformed using RxJS operators like map, filter, mergeMap, catchError, etc.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is an Observer in Angular (RxJS)?

An Observer is an object that listens to an Observable.

It defines what to do when:

A new value is emitted ‚Üí next()

An error occurs ‚Üí error()

The observable completes ‚Üí complete()

In simple words:

‚úî Observable = "Someone who sends data"

‚úî Observer = "Someone who receives data"

_________________________________________________________________________________________________________________________________________________________________________________________________________________
Difference Between Observable and Promise

Feature						Observable																		Promise

Emits						Multiple values over time												Single value once

Lazy vs Eager				Lazy ‚Äî runs only when subscribed										Eager ‚Äî runs immediately when created

Cancelable					‚úÖ Yes ‚Äî you can unsubscribe											‚ùå No ‚Äî cannot cancel once started

Operators					Supports powerful RxJS operators (map, filter, retry, etc.)				No built-in operators

Error Handling				Built-in with .subscribe()												Handled with .catch()

Usage in Angular			HttpClient, Reactive Forms, Event streams								Simple async operations like fetching one-time data

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are async and await in JavaScript (and Angular)?

1. async Keyword

Declares a function as asynchronous.

Automatically returns a Promise, even if you return a regular value.

Inside an async function, you can use await.

2. await Keyword

Can only be used inside an async function.

Pauses the function execution until the Promise is resolved or rejected.

Makes asynchronous code look sequential (like synchronous code).

3. Key Differences Between async and await

Feature								async																				await

Purpose						Declares a function as asynchronous												Waits for a Promise to resolve/reject

Used With					Functions																		Inside async functions

Return Type					Always returns a Promise														Returns the resolved value of a Promise

Execution Behavior			Makes function asynchronous														Pauses execution until the Promise resolves

Error Handling				Works with try/catch inside async function										Used within async to handle async errors cleanly

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Hot vs Cold Observables in Angular (and RxJS)

In RxJS, Observables can be classified as Cold or Hot depending on when the data starts being produced and how subscribers receive it.

This distinction is important because it affects when data emission begins, whether subscribers share data, and how multicasting works in Angular apps (like with HTTP calls or event streams).

1. Cold Observables

Definition:

A Cold Observable is one that starts producing data only when a subscriber subscribes.

Each subscriber gets its own independent stream of data.

Key Point:

The data source is created per subscription ‚Äî like a private copy for every observer.

Common Examples:

HttpClient calls in Angular (this.http.get())

of(), from(), range() from RxJS

2. Hot Observables

Definition:

A Hot Observable starts producing data immediately, even before anyone subscribes.

Subscribers share the same data stream and receive only what‚Äôs emitted after they subscribe.

Key Point:

The data source is independent of subscriptions ‚Äî like a shared broadcast.

Common Examples:

DOM events (fromEvent(document, 'click'))

WebSocket streams

Subjects (new Subject()), or share() operators

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Common RxJS Operators Used in Angular

RxJS (Reactive Extensions for JavaScript) provides operators to transform, filter, combine, and manage observable streams.

They help control how data flows and how asynchronous tasks like API calls are handled.

1. map() ‚Äî Transform Data

Purpose:

Transforms each emitted value from an observable into a new value.

Similar to JavaScript‚Äôs Array.map(), but for streams.

2. switchMap() ‚Äî Switch to a New Observable

Purpose:

Cancels the previous observable and switches to a new one when a new value is emitted.

Commonly used for HTTP calls where only the latest request should be processed.

3. mergeMap() ‚Äî Flatten and Merge Streams

Purpose:

Flattens and subscribes to multiple inner observables simultaneously.

Unlike switchMap, it does not cancel previous subscriptions.

4. filter() ‚Äî Filter Emitted Values

Purpose:

Filters out emitted values that don‚Äôt meet a condition (predicate).

Only passes through values that satisfy the condition.

5. tap() ‚Äî Side Effects (without modifying the stream)

Purpose:

Executes a side effect (like logging or debugging) for each emitted value ‚Äî without altering the observable data.

6. forkJoin() ‚Äî Combine Multiple Observables

Purpose:

Executes multiple observables in parallel and emits the final combined result only when all complete.

Similar to Promise.all() but for observables.
_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is a Subject in RxJS?

A Subject in RxJS is a special type of Observable that allows multicasting ‚Äî meaning it can emit values to multiple subscribers at once.

Unlike a regular Observable (which is unicast and creates a new stream for each subscriber), a Subject acts as both an Observable and an Observer ‚Äî it can emit values and also be subscribed to.

Key Points about Subject:

It is both producer and consumer of data.

It does not hold any previous value ‚Äî new subscribers only receive future emissions.

It is useful for manually pushing values (e.g., from user interactions or event streams).

Commonly used for cross-component communication in Angular.

What is a BehaviorSubject in RxJS?

A BehaviorSubject is a special type of Subject that:

Always stores the latest value it emitted.

Requires an initial value when created.

Replays the last emitted value immediately to new subscribers.

This makes it ideal for maintaining and sharing current state across components ‚Äî e.g., the current user, theme, or login status.

Key Differences Between Subject and BehaviorSubject

Feature							Subject																	BehaviorSubject

Initial Value				‚ùå Not required															‚úÖ Must have an initial value

Stores Last Value			‚ùå No																	‚úÖ Yes

New Subscribers				Receive only future values												Receive the latest emitted value immediately

Use Case					Event emitters, notifications											State management, maintaining current data

Example Usage in Angular	Sending data between components											Sharing current user info, theme, or app state

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is ReplaySubject in Angular (RxJS)?

A ReplaySubject is a special type of Subject that remembers previous values and sends them to any new subscriber.

In simple words:

‚úî ReplaySubject = Subject + Memory

‚úî It can replay old values to new subscribers

‚úî You decide how many past values to store (buffer size)

‚≠ê Why do we use ReplaySubject?

Because sometimes new subscribers should not miss old data.

Example use cases:

Chat messages

Notifications

Logs

Stored API responses

Multi-step forms (remember previous steps)

Whenever you want new subscribers to receive past emitted values

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is State Management in Angular?

State management refers to the way an application stores, tracks, and updates data (state) that is shared across multiple components.

In a complex Angular app, you might have data like:

Logged-in user info

Shopping cart items

UI states (loading, theme, etc.)

API responses

Without proper state management, data becomes hard to synchronize ‚Äî leading to inconsistent UI, duplicate logic, and unpredictable behavior.

Types of State Management in Angular

Local State (Component-level)

Managed using component properties and services.

Example: @Input(), @Output(), or using a shared BehaviorSubject in a service.

Global State (App-level)

Managed using a state management library like NgRx, Akita, or NGXS.

Used when multiple modules or components need to share and update the same state.

What is NgRx?

NgRx (Angular Reactive Extensions) is a state management library built around the Redux pattern ‚Äî it uses actions, reducers, and selectors to manage state in a predictable, reactive way.

It is based on RxJS Observables, making it ideal for Angular‚Äôs reactive programming model.

Core Building Blocks of NgRx

Concept					Purpose

Store				Holds the application state (a single source of truth).

Action				Describes what happened (e.g., LOGIN_SUCCESS, LOAD_USERS).

Reducer				Pure function that defines how state changes based on an action.

Selector			Retrieves specific pieces of state from the store.

Effect				Handles side effects like API calls asynchronously.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

How do you improve performance in Angular?

1) Optimize Change Detection

Use OnPush so Angular checks a component only when its inputs change (by reference), an event fires inside it, or you call markForCheck.

2) Template & DOM Efficiency

trackBy with *ngFor to prevent DOM re-renders:

3) RxJS & Data Flow

Use async pipe instead of manual subscribe() to auto-unsubscribe and reduce leaks.

4) Routing & Loading Strategy

Lazy load feature modules and standalone components:

5) Build & Bundle Optimization

Build for production (AOT, optimizations, minification):

optimize API calls with caching/pagination, and use things like Angular Universal or service workers when needed.
_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is Change Detection in Angular?

Change Detection in Angular is the process by which the framework checks and updates the DOM whenever the data in your components changes.

How Change Detection Works

Angular runs change detection automatically when:

Component input properties change

An event (like a click or keypress) occurs

An async operation (like an HTTP call or Promise) completes

A timer (setTimeout, setInterval) finishes

Change Detection Strategies

Angular provides two strategies:

Default (CheckAlways)

OnPush

1. Default Strategy (CheckAlways)

This is the default behavior in Angular.

Angular runs change detection for every component in the component tree whenever any change occurs.

Even if a component‚Äôs data didn‚Äôt actually change, Angular still checks it.

2. OnPush Strategy

Tells Angular to skip checking the component unless certain conditions are met.

The component is only checked when:

One of its @Input() properties changes (by reference).

An event is triggered inside the component (e.g., button click).

You manually mark it for check using ChangeDetectorRef.markForCheck().

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is trackBy in *ngFor and Why Do We Use It?

The trackBy function in Angular‚Äôs *ngFor directive is used to improve rendering performance when looping over lists of data.

By default, Angular uses object identity comparison to detect which items have changed, added, or removed.

When the data changes, Angular destroys and recreates all DOM elements ‚Äî even if most of the data is the same.

This can lead to unnecessary re-rendering, especially for large lists.

How trackBy Works

trackBy tells Angular how to uniquely identify each item in a list, using a unique key (usually an ID).

With this, Angular can reuse existing DOM elements instead of recreating them every time the data changes.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Lazy Loading vs Preloading in Angular

Both Lazy Loading and Preloading are routing strategies in Angular used to control how and when feature modules are loaded ‚Äî which directly affects application startup time and performance.

1Ô∏è. Lazy Loading

Definition:

Lazy Loading means loading feature modules only when they are needed ‚Äî i.e., when the user navigates to a specific route for the first time.

Purpose:

To reduce initial bundle size and speed up application startup by deferring loading of non-critical modules.

How It Works:

The feature module is loaded on demand via the loadChildren property in routing.

2Ô∏è. Preloading

Definition:

Preloading means loading lazy-loaded modules in the background after the main app has loaded.

Purpose:

To improve subsequent navigation speed by preemptively loading modules without blocking the initial load.

How It Works:

You still mark modules for lazy loading using loadChildren,

but Angular preloads them asynchronously using a preloading strategy.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Difference Between FormControl and FormGroup in Angular

In Angular‚Äôs Reactive Forms, both FormControl and FormGroup are classes from the @angular/forms package.

They are used together to build and manage form data, validation, and state in a structured, reactive way.

Key Differences Table

Feature							FormControl																		FormGroup

Purpose						Tracks a single form field														Tracks a group of form fields

Data Type					Single value (string, number, boolean)											Object containing multiple key-value pairs

Validation					Applied to individual control													Can apply group-level validation

Example Use					One input like ‚Äúemail‚Äù															Entire form like ‚ÄúLogin Form‚Äù

Composition					Leaf node in form tree															Parent node (container of controls)

Access Syntax				control.value																	formGroup.get('controlName').value

_________________________________________________________________________________________________________________________________________________________________________________________________________________

How Do You Add Form Validation in Angular?

In Angular (especially with Reactive Forms), validation is handled using the Validators class from @angular/forms.

You can apply validation rules either built-in (like required, minLength, email, etc.) or custom (your own logic).

1Ô∏è. Built-in Validators

Angular provides several ready-made validators that can be directly applied to FormControl or FormGroup.

2. Custom Validators

When built-in validators aren‚Äôt enough, you can create your own validation functions ‚Äî called custom validators.

A custom validator is just a function that:

Takes a FormControl (or FormGroup),

Returns either:

null ‚Üí ‚úÖ valid, or

{ 'errorName': true } ‚Üí ‚ùå invalid.

3. Async Validators (Optional)

For server-side or asynchronous checks (like checking if an email is already taken)

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is Form Patching in Angular?

In Angular Reactive Forms, you can update form values dynamically using:

setValue()

patchValue()

Both are methods available on FormControl, FormGroup, and FormArray,

but they differ in how strictly they expect the structure of the form data.

1Ô∏è. setValue()

Definition:

Updates all controls in a FormGroup (or a single control in a FormControl).

It requires an exact match between the form model structure and the object passed.

If any form control is missing or extra, Angular will throw an error.

‚úÖ Use it when you want to update the entire form and ensure data completeness.

2. patchValue()

Definition:

Updates specific controls in a FormGroup, FormArray, or FormControl.

It doesn‚Äôt require all fields to be present in the provided object.

‚úÖ Use it when updating only part of the form (e.g., updating user profile name or email only).

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Difference Between Development Build and Production Build in Angular

										Key Differences Summary Table
										
Aspect						Development Build					Production Build

Command					ng serve / ng build				ng build --configuration production

Optimization			No								Yes (minification, tree-shaking, bundling)

Debugging Support		Full (source maps, logs)		Minimal (for performance)

Performance				Slower app, larger size			Fast app, small size

File Size				Large							Compressed

Error Messages			Detailed						Minimized / hidden

Runtime Checks			Enabled							Disabled

Environment File Used	environment.ts					environment.prod.ts

Build Time				Fast							Slightly slower (optimization step)

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is Angular CLI?

The Angular CLI (Command Line Interface) is a powerful command-line tool provided by Angular to create, build, test, and deploy Angular applications efficiently.

It automates repetitive setup and configuration tasks ‚Äî allowing developers to focus more on coding and less on manual setup.

Common Angular CLI Commands

Here‚Äôs a list of commonly used CLI commands with explanations üëá

Command													Purpose

ng new <project-name>								Creates a new Angular project

ng serve											Builds and serves the application locally on localhost:4200

ng build											Compiles the app into an output folder (dist/) for deployment

ng build --configuration 							production	Creates an optimized production build

ng generate component <name> or ng g c <name>		Generates a new component

ng generate service <name> or ng g s <name>			Generates a new service

ng generate module <name> or ng g m <name>			Generates a new module

ng generate directive <name> or ng g d <name>		Creates a new directive

ng generate pipe <name> or ng g p <name>			Creates a new custom pipe

ng test												Runs unit tests using Karma

ng e2e												Runs end-to-end (E2E) tests using Protractor

ng lint												Runs code linting to check for style or syntax errors

ng add <library>									Installs and configures a third-party library (e.g., ng add @angular/material)

ng update											Updates Angular or its dependencies to the latest compatible versions

ng version											Displays the Angular CLI and framework version information

ng doc <keyword>									Opens the official Angular documentation for that keyword in a browser

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is environment.ts in Angular?

The environment.ts file in Angular is used to store environment-specific configuration values, such as API URLs, feature flags, or app modes (development, staging, production, etc.).

It helps you separate configuration from code, so you don‚Äôt hardcode values like API endpoints or secrets directly inside your components or services.

_________________________________________________________________________________________________________________________________________________________________________________________________________________


What is Angular Compilation?

Angular applications are written in TypeScript + HTML templates.

Before the browser can run the app, this code must be compiled into JavaScript that the browser understands.

Angular offers two ways to do this compilation:

üß© Just-in-Time (JIT) Compilation ‚Äî at runtime (in the browser)

‚ö° Ahead-of-Time (AOT) Compilation ‚Äî at build time (before deployment)

1. Just-in-Time (JIT) Compilation

Definition:

In JIT compilation, Angular compiles the app in the browser at runtime ‚Äî that is, when the app is loaded.

How It Works:

The browser downloads your Angular app‚Äôs source files (components, templates, etc.).

Angular‚Äôs compiler (@angular/compiler) runs inside the browser and compiles your templates into executable JavaScript on the fly.

2Ô∏è. Ahead-of-Time (AOT) Compilation

Definition:

In AOT compilation, Angular compiles the app at build time (before it ever reaches the browser).

So, when users open the app, they get ready-to-run JavaScript ‚Äî no need for the browser to compile anything.

How It Works:

The Angular compiler (ngc) runs during the build process.

It converts HTML templates and TypeScript into efficient JavaScript ahead of time.

The compiled code is shipped to the browser directly.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

How do you share data between two components?

Input/Output

Service with Subject

Router params

Quick When-to-Use Guide

Parent ‚áÑ Child: @Input/@Output (simple, direct)

Siblings / Distant components: Shared Service + (Behavior)Subject

Bookmark/share state: Router params (path or query)

Bonus: For complex global state (auth, cart, feature data) and time-travel/debugging, use NgRx/NGXS/Akita; for localized component state, NgRx Component Store is great.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is debounceTime() & Where Used

An RxJS operator that waits for a pause in emitted values before passing the latest one.

Used to limit API calls in search boxes or auto-suggests.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

How to Unsubscribe from Observables & Why

Use:

unsubscribe() in ngOnDestroy()

or takeUntil()

or async pipe in template.

Why: Prevent memory leaks and avoid multiple subscriptions after component destruction.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Call API on Component Load (only once)

Use the ngOnInit() lifecycle hook.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

How do you deploy an Angular application?

Build production bundle: ng build --configuration production (outputs to dist/)

Host the static files (HTML/JS/CSS/assets) on:

Static hosts: Netlify, Vercel, GitHub Pages, Firebase Hosting, S3+CloudFront, Nginx/Apache

Configure SPA fallback (rewrite /* ‚Üí /index.html) for client-side routing.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is versioning and why do we use package-lock.json?

Versioning: Locks library versions to ensure consistent installs across machines/CI.

package-lock.json: Records exact dependency tree (versions & integrity) for reproducible builds and faster installs.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is ng build --prod?

Legacy alias for production build (now ng build --configuration production).

Enables AOT, optimization/minification, tree-shaking, file hashing, and env file replacement.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

How do you handle API environment configs (dev/stage/prod)?

Use files under src/environments/:

environment.ts (dev), environment.staging.ts, environment.prod.ts

Import environment in services and read environment.apiUrl.

Configure angular.json fileReplacements and build with:

ng build --configuration development|staging|production

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are Angular Decorators?

Decorators in Angular are special TypeScript functions that add metadata to classes, methods, properties, or parameters.

They tell Angular how to process or use that piece of code (like marking a class as a component or service).

Decorator   		Purpose

@Component			Defines a UI component

@NgModule			Defines an Angular module

@Injectable			Marks a class for dependency injection

@Input				Receives data from parent component

@Output				Sends data/events to parent component

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is ngDoCheck() used for?

ngDoCheck() is used to perform manual or custom change detection logic beyond Angular‚Äôs default mechanism, especially for deep or mutable object changes.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What‚Äôs the difference between ngAfterViewInit and ngAfterContentInit?

Difference Between ngAfterViewInit and ngAfterContentInit

Both are Angular lifecycle hooks, but they trigger at different stages in the component‚Äôs rendering process.

Hook						When It Runs												What It‚Äôs For												Common Use Case

ngAfterContentInit()		After content projection (using <ng-content>) 				Runs once after external content is 				Used in components that use content
							
							is inserted into the component								projected into the component	 					projection to access projected elements

ngAfterViewInit()			After the component‚Äôs own view (template + child 			Runs once after component‚Äôs view and  				Used to access child components/elements
				
							components) has been fully initialized	 					child views are ready	 							via @ViewChild or @ViewChildren
							
_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is @ViewChild and @ContentChild in Angular?

Both are decorators used to access elements or components from your template 

but they work in different contexts of the component.

1. @ViewChild

Used to access elements, directives, or child components that are part of the component‚Äôs own view (template).

The element must be declared inside the component‚Äôs template, not projected.

2. @ContentChild

Used to access projected content that comes from a parent component via <ng-content>.

It retrieves references from content projected into this component, not from its own template.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is ChangeDetectorRef in Angular?

ChangeDetectorRef is a service from Angular‚Äôs @angular/core package that gives you fine-grained control over change detection ‚Äî it lets you manually trigger, pause, or resume Angular‚Äôs automatic view updates.

Real-World Example

A chat application receiving high-frequency messages ‚Äî you might detach change detection and update manually for better performance.

A third-party SDK (like Google Maps) or WebSocket updates data outside Angular‚Äôs zone ‚Äî you use detectChanges() to refresh the UI.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is a Provider in Angular?

A provider in Angular tells the Dependency Injection (DI) system how to create or supply a dependency (like a service).

When you inject a service into a component or another service using the constructor

What are Provider Scopes?

The provider scope determines how long the service instance lives and where it‚Äôs available in the app.

Scope					Where Provided								Instance Lifetime											Use Case

'root'					App-wide									One per application									Shared/global services

'platform'				Across all Angular apps						One per platform									Multi-app pages

'any'					Lazy modules/components						One per module/tree									Isolated services

Component-level			Inside providers array						New instance per component							Localized state/service

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Difference Between Providing a Service in root vs in NgModule

Both ways register a service provider, but the scope and lifetime of the service instance differ.

Provided In			Scope					Instances								Tree-shakable			Use Case

'root'				App-wide				Single									‚úÖ Yes					Shared/global services

NgModule.providers	Module-level			One per module (new for lazy modules)	‚ùå No 					Module-specific services

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is the Purpose of the Injector Class in Angular?

The Injector class in Angular is the core part of the Dependency Injection system.

It is responsible for creating, storing, and delivering service instances (dependencies) whenever a component, directive, or another service requests them.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

How do you pass data between routes (e.g., via query params, route params, or state)?

You can pass data between routes using:

Route Params ‚Üí For required path values (e.g., IDs)

Query Params ‚Üí For optional URL-based filters

Navigation State ‚Üí For temporary, non-URL data

Route Data ‚Üí For static configuration info

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is SharedModule in Angular?

SharedModule is a custom module that you create to store common components, directives, pipes, and reusable Angular modules so they can be used across multiple feature modules.

It helps avoid duplication and makes the project clean and maintainable.

‚≠ê Why is SharedModule used? (Purpose)

‚úÖ 1. To reuse common components across the app

Example:

HeaderComponent

FooterComponent

SidebarComponent

LoaderComponent

AlertComponent

Instead of declaring them in every module, you put them in SharedModule.

‚úÖ 2. To avoid repeating CommonModule, FormsModule, etc.

Almost every module uses:

CommonModule

FormsModule

ReactiveFormsModule

Material Modules

You import them once in SharedModule and export them.

‚úÖ 3. To keep the application structure clean

Instead of cluttering every feature module with the same imports, all reusable things stay in one place.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is CommonModule in Angular?

CommonModule is an Angular module that provides common directives, pipes, and features needed in every feature module, such as:

*ngIf

*ngFor

ngSwitch

Common pipes (date, currency, uppercase, etc.)

It is used in feature modules, not in the root module.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is AppModule in Angular?

AppModule is the root module of an Angular application.

It is the main entry point where Angular starts the application and loads all the necessary components, services, and modules.

In short:

‚úî AppModule = Main container

‚úî It tells Angular what the application contains

‚úî And which component should run first (AppComponent)
_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is the purpose of NgModule in Angular?

NgModule is a decorator that turns a class into an Angular module.

Its main purpose is to organize an application into logical blocks.

In simple words:

‚úî NgModule = A container

That groups together:

Components

Directives

Pipes

Services

Other modules

So Angular knows what your app contains and how everything is connected.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is BrowserModule in Angular?

BrowserModule is a built-in Angular module that is required to run Angular applications in the browser.

It is imported only once ‚Äî in the root module (AppModule).

‚≠ê Why do we need BrowserModule? (Purpose)

BrowserModule provides the essential features needed for Angular to work in a browser:

‚úî 1. Supports rendering (DOM support)

It includes services needed to render your Angular components into the browser DOM.

‚úî 2. Includes CommonModule features

It brings commonly used directives:

*ngIf

*ngFor

ngSwitch

Pipes like date, currency, etc.

‚úî 3. Enables Change Detection

It provides features like ChangeDetectorRef, zone.js integration, etc.

‚úî 4. Bootstrapping the AppComponent

Required to start and load the root component in a browser.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is CoreModule in Angular?

CoreModule is a custom Angular module that contains singleton services, global components, and application-level features that should be loaded only once ‚Äî when the app starts.

It is typically imported only in AppModule, never in feature modules.

‚≠ê Why do we use CoreModule? (Purpose)

‚úÖ 1. To store global singleton services

Examples:

AuthService

ApiService

LoggerService

UserService

ConfigService

These should exist once in the whole app.

CoreModule guarantees this.

‚úÖ 2. Prevent duplicate service instances

If services are put in SharedModule, and SharedModule is imported everywhere ‚Üí multiple instances are created.

Putting them in CoreModule prevents this problem.

‚úÖ 3. Store global components

Like layout components used only once:

Navbar

Header

Footer

Sidebar

NotFoundPage

These should not be repeatedly declared in feature modules ‚Üí so they belong in CoreModule.

‚úÖ 4. Keep AppModule clean

CoreModule organizes all global things so AppModule stays simple.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

CoreModule vs SharedModule (Very Important)

| Topic                      | CoreModule                            | SharedModule                           |
| -------------------------- | ------------------------------------- | -------------------------------------- |
| Contains                   | Singleton services, global components | Reusable components, directives, pipes |
| Loaded                     | Only once                             | Many times                             |
| Import Location            | Only AppModule                        | Every feature module                   |
| Should contain services?   | ‚úî Yes                                 | ‚ùå No                                 |
| Should contain components? | Only global ones                      | Reusable ones                          |

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Purpose of RouterModule.forRoot() vs RouterModule.forChild()

Both methods are used to configure Angular routes, but they are meant for different levels of your app:

RouterModule.forRoot() ‚Äî App-Level Routing

Used once in the root module (AppModule).

Registers global routes and sets up the Angular Router service for the entire application.

Should only be called once in the whole app.

RouterModule.forChild() ‚Äî Feature Module Routing

Used inside feature modules (like UserModule, AdminModule, etc.).

Defines child routes specific to that module.

Does not create a new Router instance ‚Äî it reuses the one from forRoot().

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What Are Signals in Angular?

Signals are a new reactivity model introduced in Angular 16 to make state management simpler, predictable, and more efficient.

They represent a reactive value ‚Äî when that value changes, Angular automatically knows what parts of the UI depend on it and updates them.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

what is the latest version of angular? List new features in latest angular version?

As of today (November 2025) ‚úÖ the latest stable version of Angular is:

üöÄ Angular 21

Released: November 2025

Signal-Based Routing (Major Change)

Improved Control Flow (Final & Optimized)

New template syntax:

‚úÖ @if

‚úÖ @for

‚úÖ @switch

Better Performance with Signals

Standalone is Default

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is the entry point in an angular application?

The entry point of an Angular application is main.ts.

This file is responsible for bootstrapping the application, meaning it starts Angular by loading the root component (usually AppComponent) using bootstrapApplication() or bootstrapModule() in older versions.

index.html is the first file loaded by the browser, but Angular execution actually begins from main.ts.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

what is the use of angular.json and package.json

angular.json is used to configure and manage the Angular project build and workspace settings, such as applications, build options, assets, styles, scripts, and environments.

package.json is used to manage the project's dependencies, scripts, and metadata through npm.

In simple terms, angular.json controls how the Angular app runs and builds, while package.json controls what libraries the project uses.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

How to add style sheets in an angular application?

In Angular, we can add styles in two main ways:

‚úÖ globally using styles.css or by configuring the styles array in angular.json, and

‚úÖ locally at the component level using styleUrls or styles inside the component decorator.

Global styles apply to the whole application, while component styles apply only to that component.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

How to create a custom pipes?

We can create a custom pipe in Angular using the @Pipe decorator and implementing the PipeTransform interface.

A pipe must have a transform() method where we write the logic to format or transform the data.

After creating it, we register it in a module or use it as a standalone pipe and then use it in the template with the pipe (|) symbol.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Explain two way data binding in detail ?

Two-way data binding in Angular means the UI and the component stay in sync automatically.

If the user updates the UI, the component value changes, and if the component value changes, the UI updates.

How it Works?

Two-way binding is basically a combination of:

‚úÖ Property Binding [ ] (TS ‚Üí HTML)

‚úÖ Event Binding ( ) (HTML ‚Üí TS)

Known as:

üëâ Banana in a Box syntax

Internal Working (Very Important for Interview)

Angular converts this:

<input [(ngModel)]="message">

<input [ngModel]="message" (ngModelChange)="message=$event">

So:

‚úî [ngModel] ‚Üí sends data to UI

‚úî (ngModelChange) ‚Üí sends data back to component

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is a Service Worker?

A Service Worker is a background script that runs in the browser separately from the web page and can handle tasks like caching, offline support, push notifications, 

and network requests without requiring the page to be open.

xample Scenario

You open a food delivery app (like Swiggy/Zomato PWA)

1Ô∏è. First time with internet:

Service worker downloads and caches:

HTML

CSS

JS

Images

Recently viewed restaurants

2. Internet goes OFF

Still you can:

‚úÖ Open the app

‚úÖ See previously loaded restaurants

‚úÖ View menu items

‚úÖ Navigate between pages

Why?

üëâ The service worker serves data from cache instead of the server

_________________________________________________________________________________________________________________________________________________________________________________________________________________

what are modules?

In Angular, a module is a container that groups related components, directives, pipes, and services together.

It helps organize the application and tells Angular how different parts of the app fit and work together.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

what is eager and lazy loading modules?

Eager loading means modules are loaded immediately when the application starts, even if the user never visits that feature.

Lazy loading means modules are loaded only when the user navigates to that route.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

How to prevent anauthorized access in an angular application?

We prevent unauthorized access in an Angular application mainly by using route guards like CanActivate together with an authentication/authorization service.

When a user tries to open a protected route, the guard checks whether the user is logged in and has the required role/permission.

If not, we redirect them to the login or ‚Äúaccess denied‚Äù page.

We also use HTTP interceptors to attach tokens to API calls and always enforce authorization on the backend, because Angular alone cannot provide complete security.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are Services in Angular?

Services in Angular are classes used to share data and logic across multiple components.

They contain reusable business logic, such as API calls, data processing, authentication, or state management, and are typically injected using Dependency Injection (DI).

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is View Encapsulation in Angular?

View Encapsulation in Angular controls how component styles are applied, and whether they stay inside the component or leak out to affect other components.

Types of View Encapsulation

Angular provides 3 types:

‚úÖ 1. Emulated (Default)

encapsulation: ViewEncapsulation.Emulated

‚úî Styles apply only to that component

‚úî Most commonly used

‚ùå Not real shadow DOM

2. ShadowDom

encapsulation: ViewEncapsulation.ShadowDom

‚úî Uses browser‚Äôs real Shadow DOM

‚úî True style isolation

‚ùå Limited CSS features support

3. None

encapsulation: ViewEncapsulation.None

‚úî Styles become global

‚ùå Can break other components

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is a Single Page Application (SPA)?

A Single Page Application is a web application that loads only one HTML page, and then updates the content dynamically using JavaScript without reloading the entire page.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Difference between @Component and @Directive

@Component is a special type of directive that has a template (HTML) and controls a view.

@Directive does NOT have its own template ‚Äî it is used to change behavior or appearance of existing DOM elements or components.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

How to add animations in Angular?

To add animations in Angular, we use the Angular Animations API from @angular/animations.

We enable animations by importing BrowserAnimationsModule and then define animations inside the component using trigger, state, style, and transition.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

How to add animations in Angular?

To add animations in Angular, we use the Angular Animations API from @angular/animations.

We enable animations by importing BrowserAnimationsModule and then define animations inside the component using trigger, state, style, and transition.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

How do you pass headers to HttpClient in Angular?

We pass headers to HttpClient by creating an HttpHeaders object and sending it in the request options.

The headers are included in the headers property when calling get, post, etc.

Using Interceptor (Real-time Best Practice)

In real projects, we usually add headers automatically using an interceptor

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is the Safe Navigation Operator (?.) in Angular?

The Safe Navigation Operator (?.) is used in Angular templates to prevent errors when accessing properties of null or undefined objects.

If the left side is null or undefined, Angular simply returns null instead of throwing an error.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is Content Projection in Angular?

Content Projection is a technique in Angular that allows you to pass HTML content from a parent component into a child component‚Äôs template using <ng-content>.

It lets the parent decide what content appears inside the child component.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is ng-container?

ng-container is an Angular grouping element that does NOT create any extra HTML element in the DOM, but allows you to apply structural directives like *ngIf, *ngFor, *ngSwitch, etc.

Why do we use it?

Because HTML doesn't allow multiple structural directives on the same element.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is ng-template?

ng-template is a template that is not rendered by default, but Angular can render it later when needed.

It is like a stored HTML block.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is Angular Universal?

Angular Universal is a technology that allows Angular applications to run on the server (Node.js) and generate HTML on the server before sending it to the browser.

This is called Server-Side Rendering (SSR).

Normally Angular apps run only in the browser (client-side).

With Angular Universal, the server renders the first view and sends ready HTML.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Is Angular Material responsive?

Angular Material is partially responsive.

Many components adapt to screen sizes (buttons, dialogs, nav, lists), but layout responsiveness mainly depends on Angular Flex Layout / CSS / Grid or Angular CDK Layout Breakpoints.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Why AOT is used in Production?

‚úÖ Pre-compiles templates at build time

‚úÖ Faster application startup

‚úÖ Smaller bundle size (compiler removed)

‚úÖ Better performance for users

‚úÖ Catches template errors during build

‚úÖ More secure (prevents template injection)

‚úÖ No runtime compilation needed

Why AOT is NOT used in Development?

‚ùå Slower build time

‚ùå Slower rebuild on save (HMR becomes slow)

‚ùå Harder to debug (transformed code)

‚úÖ Developers need fast build & serve

‚úÖ JIT allows quicker development cycle

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is forkJoin?

forkJoin is an RxJS operator that allows you to run multiple Observables in parallel and get the final combined result only when all of them complete.

It is similar to:

‚úÖ Promise.all() but for Observables

‚úÖ When do we use forkJoin?

Use it when:

you need data from multiple API calls

and you can continue only after ALL APIs finish

Example:

‚úÖ Get user details

‚úÖ Get user orders

‚úÖ Get user address

Then show the dashboard

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is mergeMap?

mergeMap is an RxJS operator used to map a value to an inner Observable and subscribe to multiple inner Observables at the same time (in parallel).

It does NOT cancel previous subscriptions.

‚úÖ Simple Meaning

mergeMap is used when:

‚úÖ you want to call multiple async tasks

‚úÖ let them run in parallel

‚úÖ and get all results as they arrive

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Difference between forkJoin and MergeMap

SIMPLE CORE DIFFERENCE

‚úÖ forkJoin

‚Üí Waits for ALL Observables to finish

‚Üí Emits ONE final combined result

‚Üí Completes

‚úÖ mergeMap

‚Üí Runs multiple Observables in parallel

‚Üí Emits each result as it arrives

‚Üí Keeps listening (continuous)

_________________________________________________________________________________________________________________________________________________________________________________________________________________

1. mergeMap(flatMap)

‚úÖ Definition

Runs multiple inner Observables in parallel and emits results as they arrive.

‚úÖ When to use

When tasks are independent and can run at the same time.

‚úÖ Real-Time Example

Uploading multiple files:

from(files).pipe(

  mergeMap(file => this.upload(file))

).subscribe(res => console.log(res));

‚úÖ All uploads start together

‚úÖ Each result comes separately

‚úÖ Memory Trick

üëâ "MERGE = PARALLEL"

_________________________________________________________________________________________________________________________________________________________________________________________________________________

2. concatMap

‚úÖ Definition

Runs Observables one after another (sequentially).

‚úÖ When to use

When order matters or next depends on previous.

‚úÖ Real-Time Example

Order processing:

from(orders).pipe(

  concatMap(order => this.processOrder(order))

).subscribe();

‚úÖ Order 2 starts ONLY after Order 1 completes

‚úÖ Safe for dependent APIs

‚úÖ Memory Trick

üëâ "CONCAT = QUEUE"

_________________________________________________________________________________________________________________________________________________________________________________________________________________

3. forkJoin

‚úÖ Definition

Runs multiple Observables in parallel and emits ONE final result when ALL complete.

‚úÖ When to use

When you need all data before continuing.

‚úÖ Real-Time Example

Loading dashboard:

forkJoin({

  user: getUser(),

  orders: getOrders(),

  settings: getSettings()

}).subscribe(result => console.log(result));

‚úÖ Show dashboard only when ALL API calls finish

‚úÖ Memory Trick

üëâ "forkJoin = Promise.all"

_________________________________________________________________________________________________________________________________________________________________________________________________________________

4. switchMap

‚úÖ Definition

Switches to a new Observable and cancels previous one.

‚úÖ When to use

Search boxes / Autocomplete / Typeahead

‚úÖ Real-Time Example

fromEvent(searchBox, 'input').pipe(

  debounceTime(300),

  switchMap(text => this.search(text))

).subscribe();

‚úÖ User types fast

‚úÖ Old API requests are cancelled

‚úÖ Only latest request matters

‚úÖ Memory Trick

üëâ "SWITCH = CANCEL previous"

_________________________________________________________________________________________________________________________________________________________________________________________________________________

exhaustMap (VERY IMPORTANT)'

‚úÖ Definition

Ignores new values until the current Observable completes

‚úÖ When to use

To prevent double clicks / duplicate submissions

‚úÖ Real-Time Example

fromEvent(button, 'click').pipe(

  exhaustMap(() => this.saveForm())

).subscribe();

‚úÖ User clicks 5 times

‚úÖ Only ONE API call is sent

‚ùå Rest are ignored

‚úÖ Memory Trick

üëâ "EXHAUST = I‚Äôm busy, wait!"

_________________________________________________________________________________________________________________________________________________________________________________________________________________

combineLatest

‚úÖ Definition

Emits whenever ANY Observable emits, combining latest values from all.

‚úÖ When to use

Filters / dynamic UI updates

‚úÖ Real-Time Example

Amazon filters:

combineLatest([

  category$,

  price$,

  rating$

]).subscribe(filters => loadProducts(filters));


Update products every time filter changes

‚úÖ Memory Trick

üëâ "LATEST + CONTINUOUS"

_________________________________________________________________________________________________________________________________________________________________________________________________________________

| Scenario              | Operator      |
| --------------------- | ------------- |
| Search typing         | switchMap     |
| Upload multiple files | mergeMap      |
| Order processing      | concatMap     |
| Prevent double submit | exhaustMap    |
| Load dashboard data   | forkJoin      |
| Filter products       | combineLatest |

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Top Differences Between JavaScript and TypeScript

| Feature                | JavaScript (JS)               | TypeScript (TS)                               |
| ---------------------- | ----------------------------- | --------------------------------------------- |
| **Type System**        | No type system (dynamic)      | Strong type system (static)                   |
| **Error Detection**    | Errors appear at runtime      | Errors caught at compile-time                 |
| **Compilation**        | No compilation needed         | Must compile to JavaScript                    |
| **File Extension**     | `.js`                         | `.ts`                                         |
| **Interfaces / Types** | ‚ùå Not available               | ‚úÖ Supported                                   |
| **Decorators**         | Limited / experimental        | Fully supported (Angular uses them)           |
| **Tooling**            | Basic intellisense            | Rich tooling (auto-complete, refactor)        |
| **OOP Support**        | Supports OOP but loosely      | Strong OOP with classes, interfaces, generics |
| **Browser Support**    | Directly runs in browser      | Needs transpiler (tsc)                        |
| **Learning Curve**     | Easy                          | More complex                                  |
| **Use Case**           | Small-to-medium apps, scripts | Enterprise-level apps (Angular, NestJS)       |

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is the difference between provider and inject?

provider and inject are two different parts of Angular‚Äôs Dependency Injection system, but they do different jobs.

üî• 1. What is a Provider?

A provider tells Angular HOW to create or supply a dependency (service).

It basically registers a service with Angular‚Äôs DI system.

‚úî Provider = Registration

It tells Angular:

"This is a service. Please create it when needed."

Without a provider, Angular cannot inject the service.

2. What is inject()?

inject() is a function used to get/use a dependency inside code (mostly without constructor).

Used in:

Standalone components

Signals

Run functions

Factory providers

Interceptors

Custom pipes

Services (rarely)

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are Hierarchical Injectors in Angular?

Hierarchical Injectors are Angular‚Äôs multi-level dependency injection system, where each module, component, and element can have its own injector.

This means:

‚úî Services can exist at different levels

‚úî Services can override parent services

‚úî Each component can have its own instance of a service

Angular doesn‚Äôt use one single injector.

It has a tree (hierarchy) of injectors.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is Wildcard Routing in Angular?

Wildcard routing is a special route in Angular used to handle undefined or invalid URLs.

It catches any route that does NOT match existing routes and usually displays a 404 Not Found page.

{ path: '**', component: PageNotFoundComponent }


_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is FormGroup in Angular?

FormGroup is a Reactive Forms class in Angular that is used to group multiple form controls into a single object.

It is like a container that holds multiple FormControls.

Think of it as:

‚úî FormGroup = Full form

‚úî FormControl = Single input field

import { FormGroup, FormControl } from '@angular/forms';

export class LoginComponent {
  loginForm = new FormGroup({
    email: new FormControl(''),
    password: new FormControl('')
  });

  submit() {
    console.log(this.loginForm.value);
  }
}

<form [formGroup]="loginForm" (ngSubmit)="submit()">
  <input formControlName="email" placeholder="Email">
  <input formControlName="password" type="password" placeholder="Password">
  <button type="submit">Login</button>
</form>



_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is FormBuilder in Angular?

FormBuilder is a service provided by Angular‚Äôs Reactive Forms module that helps you create FormGroups and FormControls in a shorter, cleaner, and easier way.

It reduces the boilerplate code needed to build forms.

constructor(private fb: FormBuilder) {}

loginForm = this.fb.group({
  email: [''],
  password: ['']
});


_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is an Async Validator in Angular?

An Async Validator is a validator that performs asynchronous operations before deciding whether a form control is valid or not.

It is used when validation depends on:

A server call

A database check

A delay

Any operation that returns an Observable or Promise

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is valueChanges in Angular?

valueChanges is an Observable provided by FormControl, FormGroup, and FormArray that emits every time the value of the form changes.

It allows you to:

Listen to input changes in real time

Perform actions based on user input

Apply dynamic validations

Enable/disable fields dynamically

Make API calls as the user types (e.g., search bar)

‚≠ê Where can valueChanges be used?

You can use it on:

FormControl

FormGroup

FormArray

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is HttpHeaders in Angular?

HttpHeaders is a class provided by Angular to set, modify, and manage HTTP request headers when making API calls using HttpClient.

Headers provide additional information to the server such as:

Authentication token

Content type

Custom headers

CORS details

API keys

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What are HttpParams in Angular?

HttpParams is a class in Angular used to set query parameters for HTTP requests.

Why do we use HttpParams?

To send:

Filters

Pagination data

Search inputs

Sorting options

Optional request parameters

API keys

Instead of building URLs manually.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Difference Between HttpClient.get() and fetch() in Angular

| Feature                                 | `HttpClient.get()` (Angular) | `fetch()` (Browser API)           |
| --------------------------------------- | ---------------------------- | --------------------------------- |
| Built-in to Angular?                    | ‚úî Yes                        | ‚ùå No (Native JS API)              |
| Returns                                 | **Observable**               | **Promise**                       |
| Auto JSON Parsing                       | ‚úî Yes                        | ‚ùå No (you must call `res.json()`) |
| Interceptors Support                    | ‚úî Yes                        | ‚ùå No                              |
| Error Handling                          | Easy (RxJS catchError)       | Hard (manual checks)              |
| Request/Response Transformation         | ‚úî Yes                        | ‚ùå Minimal                         |
| Automatic Type Safety                   | ‚úî Yes (Generics)             | ‚ùå No                              |
| Cancelling Requests                     | ‚úî Yes (RxJS unsubscribe)     | Limited (AbortController)         |
| Uses Zone.js (Angular change detection) | ‚úî Yes                        | ‚ùå No                              |
| Best For                                | Angular apps                 | General JS, Node, browsers        |

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is takeUntil in Angular (RxJS)?

takeUntil is an RxJS operator that automatically unsubscribes from an Observable when another Observable (usually a Subject) emits a value.

In simple words:

‚úî takeUntil = Stop listening when a signal is triggered

‚úî Helps prevent memory leaks

‚úî Commonly used in ngOnDestroy() to unsubscribe safely

‚≠ê Why do we need takeUntil?

Because in Angular, Observables keep running unless you unsubscribe.

If you don't unsubscribe:

Memory leaks occur

Performance drops

Old subscriptions continue firing

takeUntil solves this.

‚≠ê How takeUntil works?

You create a Subject called destroy$.

When the component is destroyed, you emit a value.

takeUntil sees that value ‚Üí unsubscribes.

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is pipe() in RxJS?

pipe() is a function used to combine multiple RxJS operators and apply them to an Observable in a clean, readable way.

In simple words:

‚úî pipe() = A way to chain RxJS operators

‚úî Makes observable transformations readable

‚úî Allows filtering, mapping, delaying, combining streams, etc.

Just like chaining methods in a sequence.

‚≠ê Why do we use pipe()?

Because you often need to:

Transform data (map)

Filter values (filter)

Take only some values (take, takeUntil)

Switch between streams (switchMap)

Delay emissions (debounceTime)

Handle errors (catchError)

And many more‚Ä¶

All these operators must be inside pipe().

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is Webpack in Angular?

Webpack is a module bundler used internally by Angular CLI to:

‚úî Bundle all your Angular files

‚úî Optimize them

‚úî Convert TypeScript ‚Üí JavaScript

‚úî Process HTML, CSS, images

‚úî Split code into chunks

‚úî Prepare everything for the browser

In simple words:

üî• Webpack = The tool that builds and packages your Angular app behind the scenes.

You rarely configure it manually because Angular CLI handles it for you.

‚≠ê Why does Angular use Webpack?

Because modern apps have:

TypeScript

Multiple components

Many JavaScript modules

CSS, images, assets

Lazy-loading modules

Build optimizations

Webpack takes ALL of them and generates:

‚úî /dist folder

‚úî Optimized JS bundles

‚úî Minified CSS + assets

‚úî Chunked lazy-loaded bundles

_________________________________________________________________________________________________________________________________________________________________________________________________________________

What is trackBy in *ngFor?

trackBy is a special function used with *ngFor to help Angular track list items efficiently.

Normally, when a list changes, Angular re-renders the entire list, which is slow for big lists.

trackBy tells Angular how to identify each item, so it updates only the changed items instead of re-rendering everything.

‚≠ê Why do we use trackBy?

‚úî Increases performance

‚úî Avoids unnecessary DOM updates

‚úî Stops Angular from destroying & recreating repeated items

‚úî Prevents input fields losing focus inside lists

‚úî Reduces flickering

Especially useful for:

Large lists

Dynamic data

Lists with input controls

Real-time updates
_________________________________________________________________________________________________________________________________________________________________________________________________________________

_________________________________________________________________________________________________________________________________________________________________________________________________________________

_________________________________________________________________________________________________________________________________________________________________________________________________________________

_________________________________________________________________________________________________________________________________________________________________________________________________________________
_________________________________________________________________________________________________________________________________________________________________________________________________________________

_________________________________________________________________________________________________________________________________________________________________________________________________________________

_________________________________________________________________________________________________________________________________________________________________________________________________________________

_________________________________________________________________________________________________________________________________________________________________________________________________________________
_________________________________________________________________________________________________________________________________________________________________________________________________________________
_________________________________________________________________________________________________________________________________________________________________________________________________________________
_________________________________________________________________________________________________________________________________________________________________________________________________________________	
